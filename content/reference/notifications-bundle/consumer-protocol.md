---
weight: 30
title: Consumer protocol
layout: bundle
outputs:
- html
- json
---

The {{< product-c8y-iot >}} Notifications 2.0 API uses a secure [WebSocket](https://en.wikipedia.org/wiki/WebSocket) to consume notifications generated by the {{< product-c8y-iot >}} API.

The new endpoint is accessible using the external {{< product-c8y-iot >}} fully qualified domain name of your {{< product-c8y-iot >}} environment and the standard SSL port 443 using a secure WebSocket connection. It is also available on the unsecured port 80 and to microservices using "cumulocity:8111" but in most cases a secure connection is preferred.

The [URI scheme](https://en.wikipedia.org/wiki/List_of_URI_schemes) therefore is "wss" and consumers use URLs starting with "wss://" followed by the fully qualified domain name of the {{< product-c8y-iot >}} environment or tenant, followed by a fixed URL path and a query string.

The fixed URL path is <kbd>/notification2/consumer/</kbd> and there are only two query string arguments:

* `token` (required). Its value must be a valid token in the form of a JWT token string as returned by a create token request to the [Tokens methods](https://{{< domain-c8y >}}/api/core/{{< c8y-current-version >}}/#tag/Tokens) of the Notifications 2.0 API. Including the token as a query string parameter avoids having to set an HTTP header which can be an issue for some WebSocket clients or proxies.

* `consumer` (optional). Its value is a non blank unique name for the consumer. 

In summary, the URLs used by consumers follow the following patterns:

```
wss://your.{{< product-c8y >}}.environment.fullqualifieddomainname/notification2/consumer/?token=yourJwtTokenRequestedFromNotification2TokenService
```

or

```
wss://your.{{< product-c8y >}}.environment.fullqualifieddomainname/notification2/consumer/?token=yourJwtTokenRequestedFromNotification2TokenService&consumer=aUniqueNameForThisConsumer
```

### WebSocket timeouts

There is a timeout of 5 minutes set on idle WebSocket connections after which the connection will be closed by the server side. Therefore the consumer must be prepared to handle closed connections which is required for fault tolerant operation in any case. All consuming microservices or applications should handle the WebSocket being closed and re-connect as necessary.

### Notification acknowledgements

The WebSocket established with such an URL is a textual bi-directional connection using UTF-8 encoding.
The WebSocket service sends a sequence of notifications to the consumer and the consumer should send back a short acknowledgement over this connection for each notification received.
This acknowledgement is for a particular notification and the server will periodically resend a notification until it is acknowledged.
This will cease once the server has received and processed an acknowledgement for a particular notification.

### Notification message header and content

A notification (transmitted service to client) consists of a header and a body (similar to an HTTP request).
The header is one or more (in practice at least 3) lines of text, separated by a `\n` (newline) character.
The end of the header is demarcated by a double new line `\n\n`.

The notification body follows the header.
This also consists of UTF text - for example a JSON document.
If the notification is binary data or includes binary data then it will be [Base64 encoded](https://en.wikipedia.org/wiki/Base64).

The header lines for a notification are as follows (separated by `\n` newlines):

* Required message identifier for message acknowledgement. This opaque value is an encoded binary 64 bit value. It must be returned as part of the acknowledgement for the notification as described below.

* The notification description on the second header line. This is a string describing what type of notification this is and its source. Measurements ("measurements"), events ("events") and alarms ("alarms") are examples of notifications, as are inventory creates, updates and deletes ("managedObjects"). There is a direct correspondence with realtime notifications which features similar notification descriptions. These are not enumerated here and are expected to increase in number in the future. For REST API notifications, they follow a 3 part format, separated by "/". More details on notification descriptions is given below.

* An action string is the third header. Examples are CREATE, UPDATE and DELETE. More actions may be added in the future. Together with the notification type they describe the logical event that generated the notification, such as a CREATE of an alarm or measurement.

Depending on the second header there may be further headers to follow but currently notifications only use the above three.
In order to be future proof and forward compatible, we encourage consumer code to cope with more headers by parsing them out but ignoring them.

See the *hello-world-notification-microservice* example in the [cumulocity-examples repository](https://github.com/SoftwareAG/cumulocity-examples/tree/develop/hello-world-notification-microservice) on how to do this.

After the headers, the notification body follows as UTF-8 text.
Typically a JSON document is carried in this text.

#### Notification description header

The second header line is the notification description string in the form of a `/`-separated path. For API notifications descriptions have three parts: tenantId, type and sourceId.

* tenantId - this the identifier for the tenant under which the notification was generated.

* type - the platform type of notification generated. For example, event, measurement, alarm or managed object.

* sourceId - the identifier of the "source" object that generated or is the subject of the notification. Source is a very loose term here, much as in "event sourcing" but generally indicates which managed object the notification is about.

Some examples are provided in [Traces](#traces) and backwards compatibility to real-time notifications is provided for.

Also see the rest of the documentation, examples and experiment to get values for events that you are interested in.

### Processing notification acknowledgements

The first header line in each notification consists of an opaque, encoded binary identifier that must be returned as is in a reply to the Notification 2.0 service in a message acknowledgement.

See the *hello-world-notification-microservice* example in the [cumulocity-examples repository](https://github.com/SoftwareAG/cumulocity-examples/tree/develop/hello-world-notification-microservice) on how to do this.
It involves sending the identifier back to the service in a self-contained WebSocket text message, that means, send back the first header without the trailing `\n` to the server.

### Dealing with notification duplication

Until a notification is acknowledged, the WebSocket service will attempt to re-deliver it.
It is therefore desirable that a notification is acknowledged as soon as possible (to help avoid duplicates).
However, this should not be done until the notification has been successfully processed to make use of the at-least-once semantics that the Notification 2.0 service provides.

Simply process the message and only return the acknowledgement identifier when that processing completes successfully.
If processing is longer than a minute or so, the service will resend the notification so the WebSocket client application must be prepared to deal with duplicates.
Duplicates can also occur due to underlying network failures, consumer crashes or perceived failures (slow transmissions) and subsequent failure masking re-transmission attempts.

A duplicate can be delivered out of order if several notifications are unacknowledged but only after follow-on notifications so should be easy to deal with.

For example, in the logical sequence 1,2,3,4, the notification number 2 can be duplicated after 3 or even 4 as in 1,2,3,2,4 or even several times, as in 1,2,3,4,2,3,2.

The notifications don't contain any unique identifier or timestamps to aid in de-duplication.
Some events are easy to de-duplicate, such as inventory events where a unique source object is first CREATED and then DELETED.
But inventory UPDATES or logically sequenced events such as alarms and measurements require application-specific sequencing.

This can be achieved by including unique identifiers, sequence numbers or timestamps in the notification JSON (body) as required.
An alternative is to look up the current value in the {{< product-c8y-iot >}} database, treating the notification as a signal only and ignoring the value carried.

As can be seen from the notification [Traces](#traces), some notifications do carry timestamps.
If the timestamps are not generated by the device client, then they may only be loosely synchronized between notifications and therefore should be used carefully or not at all for de-duplication.

